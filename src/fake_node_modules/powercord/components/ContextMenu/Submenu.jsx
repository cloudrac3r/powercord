/**
 * Powercord, a lightweight @discordapp client mod focused on simplicity and performance
 * Copyright (C) 2018-2019  aetheryx & Bowser65
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

const { AsyncComponent } = require('powercord/components');
const { React, getModule, getModuleByDisplayName, contextMenu, constants: { Colors } } = require('powercord/webpack');
const { getOwnerInstance, waitFor } = require('powercord/util');

const SliderItem = require('./Slider.jsx');
const ButtonItem = require('./Button.jsx');
const CheckboxItem = require('./Checkbox.jsx');
const ItemGroup = require('./ItemGroup.jsx');

const Clickable = AsyncComponent.from(getModuleByDisplayName('Clickable'));
const Icon = AsyncComponent.from(getModuleByDisplayName('Icon'));
const VerticalScroller = AsyncComponent.from(getModuleByDisplayName('VerticalScroller'));

let AppReferencePositionLayer = null;
let isFragment = null;
let classes = null;

setImmediate(async () => {
  AppReferencePositionLayer = { AppReferencePositionLayer } = (await getModule([ 'AppReferencePositionLayer' ])).AppReferencePositionLayer;
  isFragment = { isFragment } = (await getModule([ 'isFragment' ])).isFragment;
  classes = {
    ...await getModule([ 'scrollbar', 'scrollerWrap' ]),
    ...await getModule([ 'itemToggle', 'checkbox' ])
  };
});

class SubmenuItem extends React.PureComponent {
  constructor () {
    super();

    this.ref = React.createRef();
    this.handleClick = () => {
      if (this.props.onClick) {
        this.props.onClick();

        contextMenu.closeContextMenu();
      }
    };

    this.handleMouseEnter = () => {
      clearTimeout(this._timer);

      this.setState({
        open: true
      });
    };

    this.handleMouseLeave = () => {
      clearTimeout(this._timer);

      this._timer = setTimeout(() => this.setState({
        open: false
      }), 100);
    };

    this.setRef = (e) => this.ref.current = e;
    this.state = {
      items: []
    };
  }

  async componentDidUpdate () {
    const contextMenus = document.querySelectorAll(`.${classes.contextMenu.split(' ')[0]}`);
    if (contextMenus.length === 1) {
      const contextMenu = getOwnerInstance(await waitFor(`.${classes.contextMenu}`));
      const updater = contextMenu.props.onHeightUpdate || contextMenu._reactInternalFiber.return.memoizedProps.onHeightUpdate;
      if (typeof updater === 'function') {
        updater();
      }
    }
  }

  async componentDidMount () {
    const items = await this.props.getItems();
    return this.setState({ items });
  }

  componentWillUnmount () {
    clearTimeout(this._timer);
  }

  render () {
    const _this = this;

    const children = this.state.items.map(item => {
      switch (item.type) {
        case 'slider':
          return <SliderItem {...item} />;

        case 'button':
          return <ButtonItem {...item} />;

        case 'submenu':
          return <SubmenuItem {...item} />;

        case 'checkbox':
          return <CheckboxItem {...item} />;

        default:
          return null;
      }
    });

    const length = (0, isFragment)(children) ? children.props.children.length : children.length;
    const submenu = length === 0
      ? null
      : React.createElement(Clickable, {
        innerRef: this.setRef,
        className: [ classes.itemSubMenu, this.state.open ? classes.selected : null ].filter(Boolean).join(' '),
        onClick: this.props.disabled ? () => null : this.handleClick,
        onMouseEnter: this.props.disabled ? null : this.handleMouseEnter,
        onMouseLeave: this.props.disabled ? null : this.handleMouseLeave
      }, React.createElement('div', {
        className: classes.label
      }, this.props.name), React.createElement('div', {
        className: classes.hint
      }, this.props.hint), React.createElement(Icon, {
        name: 'Nova_Caret',
        className: classes.caret
      }), this.state.open
        ? React.createElement(AppReferencePositionLayer, {
          position: this.getLayerPosition(),
          align: this.getLayerAlignment(),
          autoInvert: true,
          nudgeAlignIntoViewport: true,
          spacing: 12,
          reference: this.ref
        // eslint-disable-next-line prefer-arrow-callback
        }, function () {
          return React.createElement('div', {
            className: classes.subMenuContext,
            onClick: (e) => e.stopPropagation()
          }, (typeof _this.props.scroller !== 'undefined' ? _this.props.scroller !== false : length > 8)
            ? React.createElement(VerticalScroller, {
              className: [ classes.contextMenu, classes.scroller ].filter(Boolean).join(' '),
              theme: classes.themeGhostHairline,
              backgroundColor: _this.props.theme === 'light' ? Colors.WHITE : Colors.PRIMARY_DARK_800
            }, children)
            : React.createElement('div', {
              className: classes.contextMenu
            }, children));
        })
        : null);

    if (this.props.seperate) {
      return React.createElement(ItemGroup, {
        children: [ submenu ]
      });
    }

    return submenu;
  }

  getLayerPosition () {
    const targetOffset = document.querySelector(`.${classes.contextMenu.split(' ')[0]}`).getBoundingClientRect();
    if (targetOffset.right + 188 > window.innerWidth) {
      return 'left';
    }

    return 'right';
  }

  getLayerAlignment () {
    const targetOffset1 = document.querySelector(`.${classes.contextMenu.split(' ')[0]}`).getBoundingClientRect();
    let targetOffset2;

    if (document.querySelector(`.${classes.subMenuContext.split(' ')[0]}`)) {
      targetOffset2 = document.querySelector(`.${classes.subMenuContext.split(' ')[0]}`).getBoundingClientRect();
    }

    if (targetOffset2) {
      if (targetOffset2.top + 298 > window.innerHeight) {
        return 'bottom';
      } else if (targetOffset2.bottom + 298 > window.innerHeight) {
        return 'bottom';
      }
    } else {
      if (targetOffset1.top > 298 && targetOffset1.bottom + 298 > window.innerHeight) {
        return 'bottom';
      }
    }

    return 'top';
  }
}

module.exports = SubmenuItem;
